(* Types *)
type ISD_AS. (* ISD_AS identifier *)
fun make_ISD_AS(int, int): ISD_AS.
reduc forall isd:int, as:int; get_isd(make_ISD_AS(isd, as)) = isd.
reduc forall isd:int, as:int; get_as(make_ISD_AS(isd, as)) = as.

type symmetric_key. (* Symmetric key *)
type keymat. (* Key material *)
type public_key. (* Public key *)
type private_key. (* Private key *)
type trust_root_configuration. (* Trust Root Configuration *)
type trust_root_configuration_request. (* Trust Root Configuration Request *)
type segments. (* Final paths *)
type as_entry. (*This object is generated by each AS on the path*)

fun make_as_entry(int, bitstring, public_key): as_entry.
reduc forall as:int, signature:bitstring, key:public_key; get_as(make_as_entry(as, signature, key)) = as.
reduc forall as:int, signature:bitstring, key:public_key; get_signature(make_as_entry(as, signature, key)) = signature.
reduc forall as:int, signature:bitstring, key:public_key; get_key(make_as_entry(as, signature, key)) = key.

type as_entry_list. (* List of AS entries*)

fun enlarge_as_list(as_entry_list, as_entry, int): as_entry_list.
fun pop(as_entry_list): as_entry_list.
fun get_head(as_entry_list): as_entry.
reduc forall l:as_entry_list, e:as_entry, e1:as_entry; pop(enlarge_as_list(e1,enlarge_as_list(l, e))) = enlarge_as_list(l, e).
reduc forall l:as_entry_list, e:as_entry; get_head(enlarge_as_list(l, e)) = e.
pred is_empty(as_entry_list).
clauses
  is_empty([]) = true;
  is_empty(_::_) = false.

pred contained_element(as_entry, as_entry_list).
clauses
  forall l:as_entry_list, e:as_entry; contained_element(e, enlarge_as_list(l, e));
  forall l:as_entry_list, e:as_entry, e1:as_entry; contained_element(e, l) -> contained_element(e, enlarge_as_list(l, e1));
  forall l:as_entry_list, e:as_entry, l1:as_entry_list; pop(enlarge_as_list(l, e)) = (l1, e) -> !contained_element(e, l1).

type segment_list. (* List of segments*)

fun enlarge_seg_list(segment_list, as_entry_list): segment_list.
fun pop_segment(segment_list): segment_list.
fun get_head_segment(segment_list): as_entry_list.
reduc forall l:segment_list, e:as_entry_list, e1:as_entry_list; pop_segment(enlarge_seg_list(e1,enlarge_seg_list(l, e))) = enlarge_seg_list(l, e).
reduc forall l:segment_list, e:as_entry_list; get_head_segment(enlarge_seg_list(l, e)) = e.
pred is_empty_segment(segment_list): bool.
clauses
  is_empty_segment(0) = true; (*I do not know if these 2 are correct but I do not know how to model it otherwise*)
  is_empty_segment(!0) = false.

pred contained_segment(as_entry_list, segment_list).
clauses
  forall l:segment_list, e:as_entry_list; contained_segment(e, enlarge_seg_list(l, e));
  forall l:segment_list, e:as_entry_list, e1:as_entry_list; contained_segment(e, l) -> contained_segment(e, enlarge_seg_list(l, e1));
  forall l:segment_list, e:as_entry_list, l1:segment_list; pop_segment(enlarge_seg_list(l, e)) = (l1, e) -> !contained_segment(e, l1).


(*Channels available*)
free ch_source_local_server: channel. (* Public channel between the source EH and Local Path Server*)
free ch_local_server_core_server: channel. (* Public channel between the Local Path Server and Core Server *)
free ch_core_server_core_remote_server: channel. (* Public channel between the Core Server and Core Remote Server, in the destination ISD*)
free ch_ASes: channel. (* Public channel between ASes*)
free ch_AS_core_server: channel. (* Public channel between AS and Remote Core Server*)


(* Cryptographic Primitives *)
(* Key Generation from Key Material *)
fun gen_key(keymat): key.
fun gen_public_key(keymat): public_key.
fun gen_private_key(keymat): private_key.

(* Symmetric Encryption and Decryption *)
fun senc(bitstring, key): bitstring.
fun sdec(bitstring, key): bitstring.

(* Symmetric Encryption and Decryption with Verification *)
reduc forall m:bitstring, k:keymat; sdec(senc(m, gen_key(k)), gen_key(k)) = m.

(* Asymmetric Encryption and Decryption *)
fun aenc(bitstring, public_key): bitstring.
fun adec(bitstring, private_key): bitstring.
reduc forall x:bitstring, y:keymat; adec(aenc(x,gen_public_key(y)),gen_private_key(y)) = x.

(* Digital Signatures *)
fun ok():result.
fun sign(bitstring, skey): bitstring.
reduc forall m:bitstring, y:keymat; getmess(sign(m,gen_private_key(y))) = m.
reduc forall m:bitstring, y:keymat; checksign(sign(m,gen_private_key(y)), gen_public_key(y)) = ok().

event send_request(ch:channel, isd_as:ISD_AS).
event end_host_received_paths(seg_list: segment_list).
event local_server_receive_path(seg_list: segment_list).
event core_server_receive_path(seg_list: segment_list).
event verify_trust_root_configuration(trc: trust_root_configuration).
event signature_verification_failed(as_identifier: as_id).
event send_segments(ch: channel, seg_list: segment_list).

(*Query definition*)
query ch:channel; isd_as:ISD_AS; event(send_request(ch:channel, isd_as:ISD_AS)).

(* Process Definitions *)
let AS_signature_finishing(number_of_ASes:int, as_list:as_entry_list, seg_list: segment_list) =
  new k:keymat; new isd_as_id:ISD_AS;
  if number_of_ASes = 0 then
    (*Base case: no more ASes to sign*)
    enlarge_seg_list(seg_list, as_list) (*It adds the AS list to the segment list*)
    out(ch_AS_core_server, seg_list) (*It sends to the Remote Core AS the segment signed by all the ASes*)
  else
    AS_signature(k, isd_as_id, as_list) (*It signs the segment and sends it to the next AS*)
    AS_signature_finishing(number_of_ASes-1, as_list)
  .

let AS_signature(keymat: keymat, isd_as_id: isd_as) = 
    let isd = get_isd(isd_as_id) in
    let as_identifier = get_as(isd_as_id) in
    let skey = gen_private_key(keymat) in 
    let pkey = gen_public_key(keymat) in
    let signature = sign(as_identifier, skey) in
    let as_entry = make_as_entry(as_identifier, signature, pkey) in
    enlarge_as_list(as_list, as_entry)
  (*TODO:
    I should find a way to send the new as_list over a channel considering each AS on the path
    and stopping it when the AS is the remote core server AS
  *)
  .

(*Iterate recursively over Segments and for each of them performs a signature verification of each AS.*)
let Segment_list_iteration(seg_list: segment_list) = 
  if is_empty_segment(seg_length) then
    (*Base case: no more segments to verify*)
    0
  else
    let as_entry_list = get_head_segment(seg_list) in
    let seg_list1 = pop_segment(seg_list) in
    AS_entry_list_signature_verification(as_entry_list);
    Segment_list_iteration(seg_list1)
  .

(*Iterate recursively over AS entries to verify each signature*)
let AS_entry_list_signature_verification(as_list: as_entry_list) = 
  if is_empty(as_entry_list) then
    (*Inner Base case, no more AS to verify*)
    0
  else
    let as_entry = get_head(as_list) in
    let as_entry_list1 = pop(as_list) in
    let as_identifier = get_as_identifier(as_entry) in
    let signature = get_signature(as_entry) in
    let pkey = get_public_key(as_entry) in
    if checksign(signature, pkey) = ok() then
      AS_entry_list_signature_verification(as_entry_list1)
    else
      event signature_verification_failed(as_identifier) (*What happens then? Is the upper recursive part correct*)
      0.
    .

let EndHost(keymat: keymat) =
  new destination: ISD_AS;
  out(ch_source_local_server, destination); (*Step 1*)
  event send_request(destination);
  in(ch_source_local_server, seg_list: segment_list); (*Step 12*)
  event end_host_received_paths(seg_list);
  Segment_list_iteration(seg_list) (*How to stop here and raise error if verification fails?*)
  out(ch_source_local_server, trc_request: trust_root_configuration_request);
  in(ch_source_local_server, trc: trust_root_configuration); (*Step 14*)
  event verify_trust_root_configuration(trc)
  .

let LocalPathServer(keymat: keymat) =
  new as: int; new as_list: as_entry_list;
  in(ch_source_local_server, isd_as);        (*Step 2*)
  out(ch_local_server_core_server, isd_as);
  event send_request(ch_local_server_core_server, isd_as);
  in(ch_local_server_core_server, seg_list: segment_list); (*Step 9*)
  event local_server_receive_path(seg_list)
  out(ch_local_server_core_server, trc_request: trust_root_configuration_request);
  in(ch_local_server_core_server, trc: trust_root_configuration); (*Step 11*)
  event verify_trust_root_configuration(trc)
  
  (*Adding personal entry and enlarging segments (how to add other segments? Since here I am only adding an as_Entry and not other segments for other servers)*)
  let skey = gen_private_key(keymat) in 
  let pkey = gen_public_key(keymat) in
  let signature = sign(as, skey) in
  let as_entry = make_as_entry(as, signature, pkey) in
  enlarge_as_list(as_list, as_entry)
  enlarge_seg_list(seg_list, as_list)  
  
  out(ch_source_local_server, seg_list);
  event send_segments(ch_source_local_server, seg_list)

  in(ch_source_local_server, trc_request: trust_root_configuration_request); (*Step 13*)
  out(ch_source_local_server, trc: trust_root_configuration);
  .

let CoreServer(keymat: keymat) =
  new as: int; new as_list: as_entry_list;

  in(ch_local_server_core_server, isd_as); (*Step 3*)
  out(ch_core_server_core_remote_server, isd_as);
  event send_request(ch_core_server_core_remote_server, isd_as); 
  in(ch_core_server_core_remote_server, seg_list: segment_list); (*Step 6*)
  event core_server_receive_path(seg_list)
  out(ch_core_server_core_remote_server, trc_request: trust_root_configuration_request);
  in(ch_core_server_core_remote_server, trc: trust_root_configuration); (*Step 8*)
  event verify_trust_root_configuration(trc)

  (*Adding personal entry and enlarging segments (how to add other segments? Since here I am only adding an as_Entry and not other segments for other servers)*)
  let skey = gen_private_key(keymat) in 
  let pkey = gen_public_key(keymat) in
  let signature = sign(as, skey) in
  let as_entry = make_as_entry(as, signature, pkey) in
  enlarge_as_list(as_list, as_entry)
  enlarge_seg_list(seg_list, as_list)

  out(ch_local_server_core_server, seg_list);
  event send_segments(ch_local_server_core_server, seg_list)

  in(ch_local_server_core_server, trc_request: trust_root_configuration_request); (*Step 10*)
  out(ch_local_server_core_server, trc: trust_root_configuration);
  .

let CoreRemoteServer(keymat: keymat, trc: trust_root_configuration) =
  new as: int;
  new as_list: as_entry_list;
  in(ch_core_server_core_remote_server, isd_as);               (*Step 4*)
  in(ch_AS_core_server, seg_list: segment_list);   (*Step 5*)
  event core_server_receive_path(seg_list)

  (*Adding personal entry and enlarging segments (how to add other segments? Since here I am only adding an as_Entry and not other segments for other servers)*)
  let skey = gen_private_key(keymat) in 
  let pkey = gen_public_key(keymat) in
  let signature = sign(as, skey) in
  let as_entry = make_as_entry(as, signature, pkey) in
  enlarge_as_list(as_list, as_entry)
  enlarge_seg_list(seg_list, as_list)
  
  out(ch_core_server_core_remote_server, seg_list);
  event send_segments(ch_core_server_core_remote_server, seg_list)
  in(ch_core_server_core_remote_server, trc_request: trust_root_configuration_request); (*Step 7*)
  out(ch_core_server_core_remote_server, trc: trust_root_configuration);
  .

process
  new trc: trust_root_configuration;
  (
    !(new k:keymat; EndHost(k))
    | !(new k:keymat; LocalPathServer(k))
    | !(new k:keymat; CoreServer(k)) 
    | !(new k:keymat; CoreRemoteServer(k, trc)) 
    | !( new as_list:as_entry_list; new seg_list:segment_list; AS_signature_finishing(10, as_list, seg_list))
  )
 
(* Query Definitions
query x: up_segment_list, y: core_segment_list, z:down_segment_list; event(end_host_receive_path(x,y,z)) ==> event(send_up_segment(x,y,z)).
query x: up_segment_list, y: core_segment_list, z:down_segment_list; event(send_up_segment(x,y,z)) ==> event(send_core_segment(y, z)).
query x: up_segment_list, y: core_segment_list, z:down_segment_list; event(send_core_segment(y, z)) ==> event(send_down_segment(z)).
*)
