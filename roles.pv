(* Types *)
type ISD_AS. (* ISD_AS identifier *)
fun make_ISD_AS(nat, nat): ISD_AS.
reduc forall isd:nat, as:nat; get_isd(make_ISD_AS(isd, as)) = isd.
reduc forall isd:nat, as:nat; get_as(make_ISD_AS(isd, as)) = as.

type AS. (* AS identifier *)
fun make_AS(nat): AS.
reduc forall as:nat; get_as_from_AS(make_AS(as)) = as.

type symmetric_key. (* Symmetric key *)
type keymat. (* Key material *)
type public_key. (* Public key *)
type private_key. (* Private key *)
type trust_root_configuration. (* Trust Root Configuration *)
type trust_root_configuration_request. (* Trust Root Configuration Request *)
type segments. (* Final paths *)
type as_entry. (*This object is generated by each AS on the path*)
type result.

fun make_as_entry(AS, bitstring, public_key): as_entry.
reduc forall as:AS, signature:bitstring, key:public_key; get_as_from_entry(make_as_entry(as, signature, key)) = as.
reduc forall as:AS, signature:bitstring, key:public_key; get_signature(make_as_entry(as, signature, key)) = signature.
reduc forall as:AS, signature:bitstring, key:public_key; get_public_key(make_as_entry(as, signature, key)) = key.

type as_entry_list. (* List of AS entries*)

const empty_as_list: as_entry_list.
fun enlarge_as_list(as_entry_list, as_entry): as_entry_list.
reduc forall l:as_entry_list, e:as_entry, e1:as_entry; pop(enlarge_as_list(enlarge_as_list(l, e),e1)) = enlarge_as_list(l, e).
reduc forall l:as_entry_list, e:as_entry; get_head(enlarge_as_list(l, e)) = e.

pred not_contained_element(as_entry, as_entry_list).
clauses
  forall e:as_entry, e1:as_entry, l:as_entry_list; not_contained_element(e1, enlarge_as_list(l, e)).

pred contained_element(as_entry, as_entry_list).
clauses
  forall l:as_entry_list, e:as_entry; contained_element(e, enlarge_as_list(l, e));
  forall l:as_entry_list, e:as_entry, e1:as_entry; contained_element(e, l) -> contained_element(e, enlarge_as_list(l, e1));
  forall l:as_entry_list, e:as_entry, l1:as_entry_list; pop(enlarge_as_list(l, e)) = l1 -> not_contained_element(e, l1).

type segment_list. (* List of segments*)
const empty_seg_list: segment_list.
fun enlarge_seg_list(segment_list, as_entry_list): segment_list.
reduc forall l:segment_list, e:as_entry_list, e1:as_entry_list; pop_segment(enlarge_seg_list(enlarge_seg_list(l, e),e1)) = enlarge_seg_list(l, e).
reduc forall l:segment_list, e:as_entry_list; get_head_segment(enlarge_seg_list(l, e)) = e.

pred not_contained_segment(as_entry_list, segment_list).
clauses
  forall e:as_entry_list, e1:as_entry_list, l:segment_list; not_contained_segment(e1, enlarge_seg_list(l, e)).

pred contained_segment(as_entry_list, segment_list).
clauses
  forall l:segment_list, e:as_entry_list; contained_segment(e, enlarge_seg_list(l, e));
  forall l:segment_list, e:as_entry_list, e1:as_entry_list; contained_segment(e, l) -> contained_segment(e, enlarge_seg_list(l, e1));
  forall l:segment_list, e:as_entry_list, l1:segment_list; pop_segment(enlarge_seg_list(l, e)) = l1 -> not_contained_segment(e, l1).


(*Channels available*)
free ch_source_local_server: channel [private]. (* Private channel between the source EH and Local Path Server, established with TLS*)
free ch_local_server_core_server: channel . (* Private channel between the Local Path Server and Core Server, established with TLS*)
free ch_core_server_core_remote_server: channel . (* Private channel between the Core Server and Core Remote Server, in the destination ISD. Established with TLS*)
free ch_AS_core_server: channel . (* Private channel between AS and Remote Core Server, established with TLS.*)

(* Cryptographic Primitives *)
fun gen_public_key(keymat): public_key.
fun gen_private_key(keymat): private_key.

(* Asymmetric Encryption and Decryption *)
fun aenc(bitstring, public_key): bitstring.
reduc forall x:bitstring, y:keymat; adec(aenc(x,gen_public_key(y)),gen_private_key(y)) = x.

(* Digital Signatures *)
fun ok():result.
fun sign(AS, private_key): bitstring.
reduc forall m:AS, y:keymat; getmess(sign(m,gen_private_key(y))) = m.
reduc forall m:AS, y:keymat; checksign(sign(m,gen_private_key(y)), gen_public_key(y)) = ok().

event send_request(channel, ISD_AS).
event end_host_received_paths(as_entry_list).
event local_server_receive_path(as_entry_list).
event core_server_receive_path(as_entry_list).
event remote_core_server_receive_path(as_entry).
event verify_trust_root_configuration(trust_root_configuration).
event signature_verification_failed(AS).
event send_segments(channel, as_entry_list).
event signature_done_local_path_server(public_key).
event signature_verification_successful_end_local(public_key).
event signature_verification_successful_end_core(public_key).
event signature_verification_successful_end_remote_core(public_key).
event signature_verification_successful_end_dest(public_key).

(*Query definition*)
(*query k: keymat; event(signature_verification_successful_end_local(gen_public_key(k))) ==> event(signature_done_local_path_server(gen_public_key(k))).
*)
query isd_as: ISD_AS; event(send_request(ch_source_local_server, isd_as)). (*Expected to be true*)
query as: as_entry; event(remote_core_server_receive_path(as)).

query isd_as: ISD_AS; event(send_request(ch_local_server_core_server, isd_as)). (*Expected to be true*)
query isd_as: ISD_AS; event(send_request(ch_core_server_core_remote_server, isd_as)). (*Expected to be true*)

query as_list: as_entry_list; event(end_host_received_paths(as_list)).
query as_list: as_entry_list; event(local_server_receive_path(as_list)).
query as_list: as_entry_list; event(core_server_receive_path(as_list)).
(*
query trc: trust_root_configuration; event(verify_trust_root_configuration(trc)).
query keymat: keymat; event(signature_verification_successful_end_local(gen_public_key(keymat))).
query keymat: keymat; event(signature_verification_successful_end_core(gen_public_key(keymat))).
query keymat: keymat; event(signature_verification_successful_end_remote_core(gen_public_key(keymat))).
query keymat: keymat; event(signature_verification_successful_end_dest(gen_public_key(keymat))).
query as: AS; event(signature_verification_failed(as)).*)
(*query isd_as: ISD_AS; event(send_request(ch_local_server_core_server, isd_as)) ==> event(send_request(ch_source_local_server, isd_as)) . (*Expected to be true*)
*)

(*Rules*)
(*EH sends a request to the Local Path Server*)
(*Verified( pk(key)) -> Done(  pk(key)) || attacker( key) *)

let AS_signature_finishing() =
  new k:keymat; new as_identifier:AS;
    let skey = gen_private_key(k) in 
    let pkey = gen_public_key(k) in
    let signature = sign(as_identifier, skey) in
    let single_signature = make_as_entry(as_identifier, signature, pkey) in
    out(ch_AS_core_server, single_signature) (*It sends to the Remote Core AS the segment signed by the single AS*)
  .

let AS_signature_verification(signatures_to_verify: as_entry_list, trc_request: trust_root_configuration_request) =
  let AS_destination = get_head(signatures_to_verify) in
  let signatures_to_verify1 = pop(signatures_to_verify) in
  let core_remote_as = get_head(signatures_to_verify1) in
  let signatures_to_verify2 = pop(signatures_to_verify1) in
  let core_local_as = get_head(signatures_to_verify2) in
  let signatures_to_verify3 = pop(signatures_to_verify2) in
  let local_as = get_head(signatures_to_verify3) in

  (*Extraction from destination entry*)
  let dest_as_identifier = get_as_from_entry(AS_destination) in
  let dest_signature = get_signature(AS_destination) in
  let dest_pkey = get_public_key(AS_destination) in

  (*Extraction from core remote entry*)
  let core_remote_as_identifier = get_as_from_entry(core_remote_as) in
  let core_remote_signature = get_signature(core_remote_as) in
  let core_remote_pkey = get_public_key(core_remote_as) in

  (*Extraction from core local entry*)
  let core_local_as_identifier = get_as_from_entry(core_local_as) in
  let core_local_signature = get_signature(core_local_as) in
  let core_local_pkey = get_public_key(core_local_as) in

  (*Extraction from local entry*)
  let local_as_identifier = get_as_from_entry(local_as) in
  let local_signature = get_signature(local_as) in
  let local_pkey = get_public_key(local_as) in

  if checksign(local_signature, local_pkey) = ok() then
    event signature_verification_successful_end_local(local_pkey)
  else
    event signature_verification_failed(local_as_identifier); (*What happens then? Is the upper recursive part correct*)

  if checksign(core_local_signature, core_local_pkey) = ok() then
    event signature_verification_successful_end_core(core_local_pkey)
  else
    event signature_verification_failed(core_local_as_identifier); (*What happens then? Is the upper recursive part correct*)

  if checksign(core_remote_signature, core_remote_pkey) = ok() then
    event signature_verification_successful_end_remote_core(core_remote_pkey)
  else
    event signature_verification_failed(core_remote_as_identifier); (*What happens then? Is the upper recursive part correct*)
  
  if checksign(dest_signature, dest_pkey) = ok() then
    event signature_verification_successful_end_dest(dest_pkey)
  else
    event signature_verification_failed(dest_as_identifier); (*What happens then? Is the upper recursive part correct*)
    
  out(ch_source_local_server, trc_request);
  in(ch_source_local_server, trc: trust_root_configuration); 
  event verify_trust_root_configuration(trc)
  .

let EndHost(keymat: keymat) =
  new destination: ISD_AS;
  new trc_request: trust_root_configuration_request;
  event send_request(ch_source_local_server, destination);
  out(ch_source_local_server, destination); (*Step 1*)
  in(ch_source_local_server, as_list: as_entry_list); (*Step 12*)
  event end_host_received_paths(as_list);
  AS_signature_verification(as_list, trc_request) (*How to stop here and raise error if verification fails?*)
  .

let LocalPathServer(keymat: keymat) =
  new as:AS;
  new made_trc_request: trust_root_configuration_request;
  in(ch_source_local_server, isd_as: ISD_AS);        (*Step 2*)
  event send_request(ch_local_server_core_server, isd_as);
  out(ch_local_server_core_server, isd_as);
  in(ch_local_server_core_server, as_list: as_entry_list); (*Step 9*)
  event local_server_receive_path(as_list);
  out(ch_local_server_core_server, made_trc_request);
  in(ch_local_server_core_server, trc: trust_root_configuration); (*Step 11*)
  event verify_trust_root_configuration(trc);
  
  (*Adding personal entry and enlarging segments (how to add other segments? Since here I am only adding an as_Entry and not other segments for other servers)*)
  let skey = gen_private_key(keymat) in 
  let pkey = gen_public_key(keymat) in
  let signature = sign(as, skey) in
  let as_entry_new = make_as_entry(as, signature, pkey) in
  let updated_list = enlarge_as_list(as_list, as_entry_new) in
  event signature_done_local_path_server(pkey);
  out(ch_source_local_server, updated_list);
  event send_segments(ch_source_local_server, updated_list);

  in(ch_source_local_server, trc_request: trust_root_configuration_request); (*Step 13*)
  out(ch_source_local_server, trc)
  .

let CoreServer(keymat: keymat) =
  new as: AS;
  new made_trc_request: trust_root_configuration_request;

  in(ch_local_server_core_server, isd_as: ISD_AS); (*Step 3*)
  out(ch_core_server_core_remote_server, isd_as);
  event send_request(ch_core_server_core_remote_server, isd_as); 
  in(ch_core_server_core_remote_server, as_list: as_entry_list); (*Step 6*)
  event core_server_receive_path(as_list);
  out(ch_core_server_core_remote_server, made_trc_request);
  in(ch_core_server_core_remote_server, trc: trust_root_configuration); (*Step 8*)
  event verify_trust_root_configuration(trc);

  (*Adding personal entry and enlarging segments (how to add other segments? Since here I am only adding an as_Entry and not other segments for other servers)*)
  let skey = gen_private_key(keymat) in 
  let pkey = gen_public_key(keymat) in
  let signature = sign(as, skey) in
  let as_entry_new = make_as_entry(as, signature, pkey) in
  let updated_list = enlarge_as_list(as_list, as_entry_new) in

  out(ch_local_server_core_server, updated_list);
  event send_segments(ch_local_server_core_server, updated_list);

  in(ch_local_server_core_server, trc_request: trust_root_configuration_request); (*Step 10*)
  out(ch_local_server_core_server, trc)
  .

let CoreRemoteServer(keymat: keymat, trc: trust_root_configuration) =
  new as: AS;
  new as_list: as_entry_list;
  in(ch_core_server_core_remote_server, isd_as: ISD_AS);               (*Step 4*)
  in(ch_AS_core_server, single_signature: as_entry);   (*Step 5*)
  event remote_core_server_receive_path(single_signature);

  (*Adding personal entry and enlarging segments (how to add other segments? Since here I am only adding an as_Entry and not other segments for other servers)*)
  let skey = gen_private_key(keymat) in 
  let pkey = gen_public_key(keymat) in
  let signature = sign(as, skey) in
  let as_entry_new = make_as_entry(as, signature, pkey) in
  let updated_list = enlarge_as_list(as_list, as_entry_new) in
  
  out(ch_core_server_core_remote_server, updated_list);
  event send_segments(ch_core_server_core_remote_server, updated_list);
  in(ch_core_server_core_remote_server, trc_request: trust_root_configuration_request); (*Step 7*)
  out(ch_core_server_core_remote_server, trc)
  .

process
  new trc: trust_root_configuration;
  (
    (new k:keymat; EndHost(k))
    | (new k:keymat; LocalPathServer(k))
    | (new k:keymat; CoreServer(k)) 
    | (new k:keymat; CoreRemoteServer(k, trc)) 
    | ( AS_signature_finishing())
  )
