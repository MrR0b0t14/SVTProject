(* Types *)
type ISD_AS. (* ISD_AS identifier *)
fun make_ISD_AS(nat, nat): ISD_AS.
reduc forall isd:nat, as:nat; get_isd(make_ISD_AS(isd, as)) = isd.
reduc forall isd:nat, as:nat; get_as(make_ISD_AS(isd, as)) = as.

type AS. (* AS identifier *)
fun make_AS(nat): AS.
reduc forall as:nat; get_as_from_AS(make_AS(as)) = as.

type symmetric_key. (* Symmetric key *)
type keymat. (* Key material *)
type public_key. (* Public key *)
type private_key. (* Private key *)
type trust_root_configuration. (* Trust Root Configuration *)
type trust_root_configuration_request. (* Trust Root Configuration Request *)
type segments. (* Final paths *)
type as_entry. (*This object is generated by each AS on the path*)
type result.

fun make_as_entry(AS, bitstring, public_key): as_entry.
reduc forall as:AS, signature:bitstring, key:public_key; get_as_from_entry(make_as_entry(as, signature, key)) = as.
reduc forall as:AS, signature:bitstring, key:public_key; get_signature(make_as_entry(as, signature, key)) = signature.
reduc forall as:AS, signature:bitstring, key:public_key; get_public_key(make_as_entry(as, signature, key)) = key.

type as_entry_list. (* List of AS entries*)

const empty_as_list: as_entry_list.
fun enlarge_as_list(as_entry_list, as_entry): as_entry_list.
reduc forall l:as_entry_list, e:as_entry, e1:as_entry; pop(enlarge_as_list(enlarge_as_list(l, e),e1)) = enlarge_as_list(l, e).
reduc forall l:as_entry_list, e:as_entry; get_head(enlarge_as_list(l, e)) = e.

pred not_contained_element(as_entry, as_entry_list).
clauses
  forall e:as_entry, e1:as_entry, l:as_entry_list; not_contained_element(e1, enlarge_as_list(l, e)).

pred contained_element(as_entry, as_entry_list).
clauses
  forall l:as_entry_list, e:as_entry; contained_element(e, enlarge_as_list(l, e));
  forall l:as_entry_list, e:as_entry, e1:as_entry; contained_element(e, l) -> contained_element(e, enlarge_as_list(l, e1));
  forall l:as_entry_list, e:as_entry, l1:as_entry_list; pop(enlarge_as_list(l, e)) = l1 -> not_contained_element(e, l1).

type segment_list. (* List of segments*)
const empty_seg_list: segment_list.
fun enlarge_seg_list(segment_list, as_entry_list): segment_list.
reduc forall l:segment_list, e:as_entry_list, e1:as_entry_list; pop_segment(enlarge_seg_list(enlarge_seg_list(l, e),e1)) = enlarge_seg_list(l, e).
reduc forall l:segment_list, e:as_entry_list; get_head_segment(enlarge_seg_list(l, e)) = e.

pred not_contained_segment(as_entry_list, segment_list).
clauses
  forall e:as_entry_list, e1:as_entry_list, l:segment_list; not_contained_segment(e1, enlarge_seg_list(l, e)).

pred contained_segment(as_entry_list, segment_list).
clauses
  forall l:segment_list, e:as_entry_list; contained_segment(e, enlarge_seg_list(l, e));
  forall l:segment_list, e:as_entry_list, e1:as_entry_list; contained_segment(e, l) -> contained_segment(e, enlarge_seg_list(l, e1));
  forall l:segment_list, e:as_entry_list, l1:segment_list; pop_segment(enlarge_seg_list(l, e)) = l1 -> not_contained_segment(e, l1).


(*Channels available*)
free ch_source_local_server: channel. (* Public channel between the source EH and Local Path Server*)
free ch_local_server_core_server: channel. (* Public channel between the Local Path Server and Core Server *)
free ch_core_server_core_remote_server: channel. (* Public channel between the Core Server and Core Remote Server, in the destination ISD*)
free ch_ASes: channel. (* Public channel between ASes*)
free ch_AS_core_server: channel. (* Public channel between AS and Remote Core Server*)
free ch_inner: channel. (* Private channel between ASes*)

(* Cryptographic Primitives *)
(* Key Generation from Key Material *)
fun gen_public_key(keymat): public_key.
fun gen_private_key(keymat): private_key.

(* Asymmetric Encryption and Decryption *)
fun aenc(bitstring, public_key): bitstring.
reduc forall x:bitstring, y:keymat; adec(aenc(x,gen_public_key(y)),gen_private_key(y)) = x.

(* Digital Signatures *)
fun ok():result.
fun sign(AS, private_key): bitstring.
reduc forall m:AS, y:keymat; getmess(sign(m,gen_private_key(y))) = m.
reduc forall m:AS, y:keymat; checksign(sign(m,gen_private_key(y)), gen_public_key(y)) = ok().

event send_request(channel, ISD_AS).
event end_host_received_paths(as_entry_list).
event local_server_receive_path(as_entry_list).
event core_server_receive_path(as_entry_list).
event verify_trust_root_configuration(trust_root_configuration).
event signature_verification_failed(AS).
event signature_verification_ok(AS).
event send_segments(channel, as_entry_list).

(*Query definition*)
query ch:channel, isd_as:ISD_AS; event(send_request(ch, isd_as)).
(*
(* Process Definitions *)
let AS_signature_finishing(number_of_ASes:nat, as_list:as_entry_list, seg_list: segment_list) =
  new k:keymat; new isd_as_id:ISD_AS;
  if number_of_ASes = 0 then
  (
    (*Base case: no more ASes to sign*)
    let new_seg_list = enlarge_seg_list(seg_list, as_list) in (*It adds the AS list to the segment list*)
    out(ch_AS_core_server, new_seg_list) (*It sends to the Remote Core AS the segment signed by all the ASes*)
  )
  else
    let as_identifier = get_as(isd_as_id) in
    let skey = gen_private_key(k) in 
    let pkey = gen_public_key(k) in
    let signature = sign(as_identifier, skey) in
    let as_entry_new = make_as_entry(as_identifier, signature, pkey) in
    let new_list = enlarge_as_list(as_list, as_entry_new) in
    AS_signature_finishing(number_of_ASes-1, new_list)(*It signs the segment and sends it to the next AS*)
    (*It receives the AS list from the previous AS*)
    (**)
    .

(*Iterate recursively over Segments and for each of them performs a signature verification of each AS.*)
let Segment_list_iteration(seg_list: segment_list, trc_request: trust_root_configuration_request) = 
  if seg_list = empty_seg_list then
    ((*Base case: no more segments to verify*)
      out(ch_source_local_server, trc_request);
      in(ch_source_local_server, trc: trust_root_configuration); (*Step 14*)
      event verify_trust_root_configuration(trc)
    )
  else
    let as_entry_list = get_head_segment(seg_list) in
    let seg_list1 = pop_segment(seg_list) in
    AS_entry_list_signature_verification(as_entry_list)
  .

(*Iterate recursively over AS entries to verify each signature*)
let AS_entry_list_signature_verification(as_list: as_entry_list) = 
  if as_list = empty_as_list then
    Segment_list_iteration(as_list, trc_request)
  else
    let as_entry = get_head(as_list) in
    let as_entry_list1 = pop(as_list) in
    let as_identifier = get_as_identifier(as_entry) in
    let signature = get_signature(as_entry) in
    let pkey = get_public_key(as_entry) in
    if checksign(signature, pkey) = ok() then
      AS_entry_list_signature_verification(as_entry_list1)
    else
      event signature_verification_failed(as_identifier) (*What happens then? Is the upper recursive part correct*)
    .
*)

let AS_signature_finishing() =
  new k:keymat; new as_identifier:AS;
    let skey = gen_private_key(k) in 
    let pkey = gen_public_key(k) in
    let signature = sign(as_identifier, skey) in
    let single_signature = make_as_entry(as_identifier, signature, pkey) in
    out(ch_AS_core_server, single_signature) (*It sends to the Remote Core AS the segment signed by the single AS*)
  .

let AS_signature_verification(signatures_to_verify: as_entry_list, trc_request: trust_root_configuration_request) =
  let AS_destination = get_head(signatures_to_verify) in
  let signatures_to_verify1 = pop(signatures_to_verify) in
  let core_remote_as = get_head(signatures_to_verify1) in
  let signatures_to_verify2 = pop(signatures_to_verify1) in
  let core_local_as = get_head(signatures_to_verify2) in
  let signatures_to_verify3 = pop(signatures_to_verify2) in
  let local_as = get_head(signatures_to_verify3) in

  (*Extraction from destination entry*)
  let dest_as_identifier = get_as_from_entry(AS_destination) in
  let dest_signature = get_signature(AS_destination) in
  let dest_pkey = get_public_key(AS_destination) in

  (*Extraction from core remote entry*)
  let core_remote_as_identifier = get_as_from_entry(core_remote_as) in
  let core_remote_signature = get_signature(core_remote_as) in
  let core_remote_pkey = get_public_key(core_remote_as) in

  (*Extraction from core local entry*)
  let core_local_as_identifier = get_as_from_entry(core_local_as) in
  let core_local_signature = get_signature(core_local_as) in
  let core_local_pkey = get_public_key(core_local_as) in

  (*Extraction from local entry*)
  let local_as_identifier = get_as_from_entry(local_as) in
  let local_signature = get_signature(local_as) in
  let local_pkey = get_public_key(local_as) in

  if checksign(dest_signature, dest_pkey) = ok() then
    event signature_verification_ok(dest_as_identifier)
  else
    event signature_verification_failed(dest_as_identifier); (*What happens then? Is the upper recursive part correct*)
  
  if checksign(core_remote_signature, core_remote_pkey) = ok() then
    event signature_verification_ok(core_remote_as_identifier)
  else
    event signature_verification_failed(core_remote_as_identifier); (*What happens then? Is the upper recursive part correct*)
  
  if checksign(core_local_signature, core_local_pkey) = ok() then
    event signature_verification_ok(core_local_as_identifier)
  else
    event signature_verification_failed(core_local_as_identifier); (*What happens then? Is the upper recursive part correct*)

  if checksign(local_signature, local_pkey) = ok() then
    event signature_verification_ok(local_as_identifier)
  else
    event signature_verification_failed(local_as_identifier); (*What happens then? Is the upper recursive part correct*)

  out(ch_source_local_server, trc_request);
  in(ch_source_local_server, trc: trust_root_configuration); 
  event verify_trust_root_configuration(trc)
  .

let EndHost(keymat: keymat) =
  new destination: ISD_AS;
  new trc_request: trust_root_configuration_request;
  out(ch_source_local_server, destination); (*Step 1*)
  event send_request(ch_source_local_server, destination);
  in(ch_source_local_server, as_list: as_entry_list); (*Step 12*)
  event end_host_received_paths(as_list);
  AS_signature_verification(as_list, trc_request) (*How to stop here and raise error if verification fails?*)
  .

let LocalPathServer(keymat: keymat) =
  new as:AS;
  new trc_request: trust_root_configuration_request;
  in(ch_source_local_server, isd_as: ISD_AS);        (*Step 2*)
  out(ch_local_server_core_server, isd_as);
  event send_request(ch_local_server_core_server, isd_as);
  in(ch_local_server_core_server, as_list: as_entry_list); (*Step 9*)
  event local_server_receive_path(as_list);
  out(ch_local_server_core_server, trc_request);
  in(ch_local_server_core_server, trc: trust_root_configuration); (*Step 11*)
  event verify_trust_root_configuration(trc);
  
  (*Adding personal entry and enlarging segments (how to add other segments? Since here I am only adding an as_Entry and not other segments for other servers)*)
  let skey = gen_private_key(keymat) in 
  let pkey = gen_public_key(keymat) in
  let signature = sign(as, skey) in
  let as_entry = make_as_entry(as, signature, pkey) in
  let updated_list = enlarge_as_list(as_list, as_entry) in
  
  out(ch_source_local_server, updated_list);
  event send_segments(ch_source_local_server, updated_list);

  in(ch_source_local_server, trc_request: trust_root_configuration_request); (*Step 13*)
  out(ch_source_local_server, trc)
  .

let CoreServer(keymat: keymat) =
  new as: AS;
  new trc_request: trust_root_configuration_request;

  in(ch_local_server_core_server, isd_as); (*Step 3*)
  out(ch_core_server_core_remote_server, isd_as);
  event send_request(ch_core_server_core_remote_server, isd_as); 
  in(ch_core_server_core_remote_server, as_list: as_entry_list); (*Step 6*)
  event core_server_receive_path(as_list);
  out(ch_core_server_core_remote_server, trc_request);
  in(ch_core_server_core_remote_server, trc: trust_root_configuration); (*Step 8*)
  event verify_trust_root_configuration(trc);

  (*Adding personal entry and enlarging segments (how to add other segments? Since here I am only adding an as_Entry and not other segments for other servers)*)
  let skey = gen_private_key(keymat) in 
  let pkey = gen_public_key(keymat) in
  let signature = sign(as, skey) in
  let as_entry = make_as_entry(as, signature, pkey) in
  let updated_list = enlarge_as_list(as_list, as_entry) in

  out(ch_local_server_core_server, updated_list);
  event send_segments(ch_local_server_core_server, updated_list);

  in(ch_local_server_core_server, trc_request: trust_root_configuration_request); (*Step 10*)
  out(ch_local_server_core_server, trc)
  .

let CoreRemoteServer(keymat: keymat, trc: trust_root_configuration) =
  new as: AS;
  new as_list: as_entry_list;
  in(ch_core_server_core_remote_server, isd_as);               (*Step 4*)
  in(ch_AS_core_server, single_signature: as_entry);   (*Step 5*)
  event core_server_receive_path(single_signature);

  (*Adding personal entry and enlarging segments (how to add other segments? Since here I am only adding an as_Entry and not other segments for other servers)*)
  let skey = gen_private_key(keymat) in 
  let pkey = gen_public_key(keymat) in
  let signature = sign(as, skey) in
  let as_entry_new = make_as_entry(as, signature, pkey) in
  let updated_list = enlarge_as_list(as_list, as_entry_new) in
  
  out(ch_core_server_core_remote_server, update_list);
  event send_segments(ch_core_server_core_remote_server, update_list);
  in(ch_core_server_core_remote_server, trc_request: trust_root_configuration_request); (*Step 7*)
  out(ch_core_server_core_remote_server, trc)
  .

process
  new trc: trust_root_configuration;
  (
    !(new k:keymat; EndHost(k))
    | !(new k:keymat; LocalPathServer(k))
    | !(new k:keymat; CoreServer(k)) 
    | !(new k:keymat; CoreRemoteServer(k, trc)) 
    | !( AS_signature_finishing())
  )
 
(* Query Definitions
query x: up_segment_list, y: core_segment_list, z:down_segment_list; event(end_host_receive_path(x,y,z)) ==> event(send_up_segment(x,y,z)).
query x: up_segment_list, y: core_segment_list, z:down_segment_list; event(send_up_segment(x,y,z)) ==> event(send_core_segment(y, z)).
query x: up_segment_list, y: core_segment_list, z:down_segment_list; event(send_core_segment(y, z)) ==> event(send_down_segment(z)).
*)
