(* Types *)
type AS. (* AS identifier *)
type ISD_AS. (* ISD_AS identifier *)
type ISD.
fun make_ISD_AS(ISD, AS): ISD_AS. 
reduc forall isd:ISD, as:AS; get_isd(make_ISD_AS(isd, as)) = isd.
reduc forall isd:ISD, as:AS; get_as(make_ISD_AS(isd, as)) = as.

fun make_AS(AS): AS.
reduc forall as:AS; get_as_from_AS(make_AS(as)) = as.

type symmetric_key. (* Symmetric key *)
type keymat. (* Key material *)
type public_key. (* Public key *)
type private_key. (* Private key *)
type trust_root_configuration. (* Trust Root Configuration *)
type trust_root_configuration_request. (* Trust Root Configuration Request *)
type segments. (* Final paths *)
type as_entry. (*This object is generated by each AS on the path*)
type result.

fun make_as_entry(AS, bitstring, public_key): as_entry.
reduc forall as:AS, signature:bitstring, key:public_key; get_as_from_entry(make_as_entry(as, signature, key)) = as.
reduc forall as:AS, signature:bitstring, key:public_key; get_signature(make_as_entry(as, signature, key)) = signature.
reduc forall as:AS, signature:bitstring, key:public_key; get_public_key(make_as_entry(as, signature, key)) = key.

type as_entry_list. (* List of AS entries*)

fun add_second(as_entry, as_entry): as_entry_list.
reduc forall e:as_entry, e1:as_entry; get_first(add_second(e, e1)) = e.
reduc forall e:as_entry, e1:as_entry; get_second(add_second(e, e1)) = e1.

fun add_third(as_entry_list, as_entry): as_entry_list.
reduc forall l:as_entry_list, e:as_entry; get_third(add_third(l, e)) = e.

fun add_fourth(as_entry_list, as_entry): as_entry_list.
reduc forall l:as_entry_list, e:as_entry; get_fourth(add_fourth(l, e)) = e.

(*Channels available*)
(*From Left to Right Flow Request*)
free ch_source_local_server: channel [private]. (* Private channel between the source EH and Local Path Server, established with TLS*)
free ch_local_server_core_server: channel [private]. (* Private channel between the Local Path Server and Core Server, established with TLS*)
free ch_core_server_core_remote_server: channel [private]. (* Private channel between the Core Server and Core Remote Server, in the destination ISD. Established with TLS*)
free ch_core_remote_AS: channel [private]. (* Private channel between Remote Core Server and AS, established with TLS.*)

(*From Right to Left Flow Response*)
free ch_AS_core_server: channel [private]. (* Private channel between AS and Remote Core Server, established with TLS.*)
free ch_core_remote_server_core_server: channel [private]. (* Private channel between Remote Core Server and Core Server, established with TLS.*)
free ch_core_server_local_server: channel [private]. (* Private channel between Core Server and Local Path Server, established with TLS.*)
free ch_local_server_source: channel [private]. (* Private channel between Local Path Server and Source EH, established with TLS.*)

(*From L to R, TRC*)
free ch_trc_core_to_remote: channel [private].
free ch_trc_local_to_core: channel [private].
free ch_trc_eh_to_local: channel [private].

(*From R to L, TRC*)
free ch_trc_remote_to_core: channel [private].
free ch_trc_core_to_local: channel [private].
free ch_trc_local_to_eh: channel [private].

(* Cryptographic Primitives *)
fun gen_public_key(keymat): public_key.
fun gen_private_key(keymat): private_key.

(* Asymmetric Encryption and Decryption *)
fun aenc(bitstring, public_key): bitstring.
reduc forall x:bitstring, y:keymat; adec(aenc(x,gen_public_key(y)),gen_private_key(y)) = x.

(* Digital Signatures *)
fun ok():result.
fun sign(AS, private_key): bitstring.
reduc forall m:AS, y:keymat; getmess(sign(m,gen_private_key(y))) = m.
reduc forall m:AS, y:keymat; checksign(sign(m,gen_private_key(y)), gen_public_key(y)) = ok().

event send_request(channel, ISD_AS).
event end_host_receive_paths(as_entry_list).
event local_server_receive_path(as_entry_list).
event core_server_receive_path(as_entry_list).
event remote_core_server_receive_path(as_entry).
event signature_verification_failed(AS).
event send_segments(channel, as_entry_list).
event signature_done_local_path_server(public_key).
event signature_done_by_AS(public_key).
event signature_verification_successful_end_local(public_key).
event signature_verification_successful_end_core(public_key).
event signature_verification_successful_end_remote_core(public_key).
event signature_verification_successful_end_dest(public_key).
event destination_received_request().
event signature_verified(public_key).
event trc_send_by_remote(trust_root_configuration).
event trc_verified_by_core_server(trust_root_configuration).
event trc_send_by_core_server(trust_root_configuration).
event trc_verified_by_local(trust_root_configuration).
event trc_send_by_local(trust_root_configuration).
event trc_verified_by_eh(trust_root_configuration).
event signature_perfomed_by_core_remote_server(public_key).
event signature_perfomed_by_core_server(public_key).
event signature_perfomed_by_local(public_key).
event dest_signature_verified(public_key).
event remote_signature_verified(public_key).
event core_signature_verified(public_key).
event local_signature_verified(public_key).

(*Query definition*)
(*query k: keymat; event(signature_verification_successful_end_local(gen_public_key(k))) ==> event(signature_done_local_path_server(gen_public_key(k))).
*)
(*Simply sanity checks for basic events - Reachability*)
query isd_as: ISD_AS; event(send_request(ch_source_local_server, isd_as)). (*Expected to be true*)
query isd_as: ISD_AS; event(send_request(ch_local_server_core_server, isd_as)). (*Expected to be true*)
query isd_as: ISD_AS; event(send_request(ch_core_server_core_remote_server, isd_as)). (*Expected to be true*)
query isd_as: ISD_AS; event(send_request(ch_core_remote_AS, isd_as)). (*Expected to be true*)
query event(destination_received_request()). (*Expected to be true*)
query pk: public_key; event(signature_done_by_AS(pk)). (*Expected to be true*)
query updated_list: as_entry_list; event(send_segments(ch_core_remote_server_core_server, updated_list)). (*Expected to be true*)
query as_list: as_entry_list; event(core_server_receive_path(as_list)). (*Expected to be true*)
query trc: trust_root_configuration; event(trc_send_by_remote(trc)). (*Expected to be true*)
query trc: trust_root_configuration; event(trc_verified_by_core_server(trc)).
query trc: trust_root_configuration; event(trc_send_by_core_server(trc)).
query trc: trust_root_configuration; event(trc_verified_by_local(trc)).
query trc: trust_root_configuration; event(trc_send_by_local(trc)).
query trc: trust_root_configuration; event(trc_verified_by_eh(trc)).
query as_list: as_entry_list; event(end_host_receive_paths(as_list)). (*Expected to be true*)
query as_list: as_entry_list; event(local_server_receive_path(as_list)). (*Expected to be true*)
query entry: as_entry; event(remote_core_server_receive_path(entry)). (*Expected to be true*)
query pk: public_key; event(signature_done_by_AS(pk)). (*Expected to be true*)
query pk: public_key; event(signature_perfomed_by_core_remote_server(pk)). (*Expected to be true*)
query pk: public_key; event(signature_perfomed_by_core_server(pk)). (*Expected to be true*)
query pk: public_key; event(signature_perfomed_by_local(pk)). (*Expected to be true*)
query pk: public_key; event(dest_signature_verified(pk)). (*Expected to be true*)
query pk: public_key; event(remote_signature_verified(pk)). (*Expected to be true*)
query pk: public_key; event(core_signature_verified(pk)). (*Expected to be true*)
query pk: public_key; event(local_signature_verified(pk)). (*Expected to be true*)
query event(error()).

(*Event Correspondence, sanity checks for the workflow of the protocol*)
query isd_as: ISD_AS; event(send_request(ch_local_server_core_server, isd_as)) ==> event(send_request(ch_source_local_server, isd_as)). (*Expected to be true*)
query isd_as: ISD_AS; event(send_request(ch_core_server_core_remote_server, isd_as)) ==> event(send_request(ch_local_server_core_server, isd_as)). (*Expected to be true*)
query isd_as: ISD_AS; event(send_request(ch_core_remote_AS, isd_as)) ==> event(send_request(ch_core_server_core_remote_server, isd_as)). (*Expected to be true*)
query isd_as: ISD_AS; event(destination_received_request()) ==> event(send_request(ch_core_remote_AS, isd_as)). (*Expected to be true*)
query paths: as_entry_list; event(send_segments(ch_core_remote_server_core_server, paths)) ==> event(destination_received_request()). (*Expected to be true*)
query paths: as_entry_list; event(core_server_receive_path(paths)) ==> event(send_segments(ch_core_remote_server_core_server, paths)). (*Expected to be true*)
query tr: trust_root_configuration; event(trc_verified_by_core_server(tr)) ==> event(trc_send_by_remote(tr)). (*Expected to be true*)
query tr: trust_root_configuration; event(trc_verified_by_local(tr)) ==> event(trc_send_by_core_server(tr)) . (*Expected to be true*)
query tr: trust_root_configuration; event(trc_verified_by_eh(tr)) ==> event(trc_send_by_local(tr)) . (*Expected to be true*)

(*Signature Verification*)
query pk: public_key; event(dest_signature_verified(pk)) ==> event(signature_done_by_AS(pk)). (*Expected to be true*)
query pk: public_key; event(remote_signature_verified(pk)) ==> event(signature_perfomed_by_core_remote_server(pk)). (*Expected to be true*)
query pk: public_key; event(core_signature_verified(pk)) ==> event(signature_perfomed_by_core_server(pk)). (*Expected to be true*)
query pk: public_key; event(local_signature_verified(pk)) ==> event(signature_perfomed_by_local(pk)). (*Expected to be true*)

(*EH sends a request to the Local Path Server*)
(*Verified( pk(key)) -> Done(  pk(key)) || attacker( key) *)

let AS_signature_finishing() =
  new k:keymat;
    in(ch_core_remote_AS, isd_as: ISD_AS);
    event destination_received_request();
    let as_identifier = get_as(isd_as) in
    let skey = gen_private_key(k) in 
    let pkey = gen_public_key(k) in
    let signature = sign(as_identifier, skey) in
    let single_signature = make_as_entry(as_identifier, signature, pkey) in
    event signature_done_by_AS(pkey);
    out(ch_AS_core_server, single_signature) (*It sends to the Remote Core AS the segment signed by the single AS*)
  .

let AS_signature_verification(signatures_to_verify: as_entry_list, trc_request: trust_root_configuration_request) =
  
  let destination_entry = get_first(signatures_to_verify) in
  let destination_pkey = get_public_key(destination_entry) in
  let destination_signature = get_signature(destination_entry) in

  let remote_entry = get_second(signatures_to_verify) in
  let remote_pkey = get_public_key(remote_entry) in
  let remote_signature = get_signature(remote_entry) in

  let core_entry = get_third(signatures_to_verify) in
  let core_pkey = get_public_key(core_entry) in
  let core_signature = get_signature(core_entry) in

  let local_entry = get_fourth(signatures_to_verify) in
  let local_pkey = get_public_key(local_entry) in
  let local_signature = get_signature(local_entry) in

  if checksign(destination_signature, destination_pkey) = ok() then
    event dest_signature_verified(destination_pkey);
  else 
    event error();

  if checksign(remote_signature, remote_pkey) = ok() then
    event remote_signature_verified(remote_pkey);

  if checksign(core_signature, core_pkey) = ok() then
    event core_signature_verified(core_pkey);
  
  if checksign(local_signature, local_pkey) = ok() then
    event local_signature_verified(local_pkey);

  out(ch_trc_eh_to_local, trc_request);
  in(ch_trc_local_to_eh, trc: trust_root_configuration); 
  event trc_verified_by_eh(trc)
  .

let EndHost(keymat: keymat) =
  new isd: ISD; (*ISD*) 
  new as: AS; (*AS*)
  new trc_request: trust_root_configuration_request;
  let destination = make_ISD_AS(isd, as) in
  event send_request(ch_source_local_server, destination);
  out(ch_source_local_server, destination); (*Step 1*)
  in(ch_local_server_source, as_list: as_entry_list); (*Step 12*)
  event end_host_receive_paths(as_list);
  AS_signature_verification(as_list, trc_request)
  .

let LocalPathServer(keymat: keymat) =
  new as:AS;
  new made_trc_request: trust_root_configuration_request;
  in(ch_source_local_server, isd_as: ISD_AS);        (*Step 2*)
  event send_request(ch_local_server_core_server, isd_as);
  out(ch_local_server_core_server, isd_as);
  in(ch_core_server_local_server, as_list: as_entry_list); (*Step 9*)
  event local_server_receive_path(as_list);
  out(ch_trc_local_to_core, made_trc_request);
  in(ch_trc_core_to_local, trc: trust_root_configuration); (*Step 11*)
  event trc_verified_by_local(trc);

  (*Adding personal entry and enlarging segments (how to add other segments? Since here I am only adding an as_Entry and not other segments for other servers)*)
  let skey = gen_private_key(keymat) in 
  let pkey = gen_public_key(keymat) in
  let signature = sign(as, skey) in
  let as_entry_new = make_as_entry(as, signature, pkey) in
  let updated_list = add_fourth(as_list, as_entry_new) in

  event send_segments(ch_source_local_server, updated_list);
  event signature_perfomed_by_local(pkey);
  out(ch_local_server_source, updated_list);
  

  in(ch_trc_eh_to_local, trc_request: trust_root_configuration_request); (*Step 13*)
  event trc_send_by_local(trc);
  out(ch_trc_local_to_eh, trc)
  .

let CoreServer(keymat: keymat) =
  new as: AS;
  new made_trc_request: trust_root_configuration_request;

  in(ch_local_server_core_server, isd_as: ISD_AS); (*Step 3*)
  event send_request(ch_core_server_core_remote_server, isd_as);
  out(ch_core_server_core_remote_server, isd_as);
  in(ch_core_remote_server_core_server, as_list: as_entry_list); (*Step 6*)
  event core_server_receive_path(as_list);

  out(ch_trc_core_to_remote, made_trc_request);
  in(ch_trc_remote_to_core, trc: trust_root_configuration); (*Step 8*)
  event trc_verified_by_core_server(trc);

  (*Adding personal entry and enlarging segments (how to add other segments? Since here I am only adding an as_Entry and not other segments for other servers)*)
  let skey = gen_private_key(keymat) in 
  let pkey = gen_public_key(keymat) in
  let signature = sign(as, skey) in
  let as_entry_new = make_as_entry(as, signature, pkey) in
  let updated_list = add_third(as_list, as_entry_new) in

  event send_segments(ch_core_server_local_server, updated_list);
  event signature_perfomed_by_core_server(pkey);
  out(ch_core_server_local_server, updated_list);
  
  in(ch_trc_local_to_core, trc_request: trust_root_configuration_request); (*Step 10*)
  event trc_send_by_core_server(trc);
  out(ch_trc_core_to_local, trc)
  .

let CoreRemoteServer(keymat: keymat, trc: trust_root_configuration) =
  new as: AS;
  in(ch_core_server_core_remote_server, isd_as: ISD_AS);               (*Step 4*)
  event send_request(ch_core_remote_AS, isd_as);
  out(ch_core_remote_AS, isd_as);
  in(ch_AS_core_server, single_signature: as_entry);   (*Step 5*)
  event remote_core_server_receive_path(single_signature);
(*  if checksign(get_signature(single_signature), get_public_key(single_signature)) then
    event signature_verified(get_public_key(single_signature))
*)
  (*Adding personal entry and enlarging segments (how to add other segments? Since here I am only adding an as_Entry and not other segments for other servers)*)
  let skey = gen_private_key(keymat) in 
  let pkey = gen_public_key(keymat) in
  let signature = sign(as, skey) in
  let as_entry_new = make_as_entry(as, signature, pkey) in
  let updated_list = add_second(single_signature, as_entry_new) in
  
  event send_segments(ch_core_remote_server_core_server, updated_list);
  event signature_perfomed_by_core_remote_server(pkey);

  (*
    IF I ADD THE OUT HERE, SINCE EVVIVA CANNOT BE PROVED, IT GOES WITH HORN CLAUSES THEN.
    THIS IS DUE BY THE DERIVATION RETURNING A PROBLEM WITH OUT AND SUDDENLY IN AT LINES 242 AND 243. 
    IT CAN BE SOLVED BY CREATING 2 CHANNELS FOR EACH MESSAGE EXCHANGE BETWEEN 2 PROCESSES.
  *)

  out(ch_core_remote_server_core_server, updated_list);
  in(ch_trc_core_to_remote, trc_request: trust_root_configuration_request); (*Step 7*)
  event trc_send_by_remote(trc);
  out(ch_trc_remote_to_core, trc)
  .

process
  new trc: trust_root_configuration;
  (
    (new k:keymat; EndHost(k))
    | (new k:keymat; LocalPathServer(k))
    | (new k:keymat; CoreServer(k))
    | (new k:keymat; CoreRemoteServer(k, trc))
    | ( AS_signature_finishing())
  )
